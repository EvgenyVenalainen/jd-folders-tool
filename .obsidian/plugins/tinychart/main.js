/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TinyChartPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings/pluginSettings.ts
var DEFAULT_SETTINGS = {
  fillChar: "\u2588",
  emptyChar: "-",
  prefixChar: "",
  suffixChar: "",
  chartLength: 20,
  codeBlock: true,
  showLabels: true,
  rightAlignLabels: true
};

// src/settings/settingsTab.ts
var import_obsidian = require("obsidian");
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Fill character").setDesc("Single character (required)").addText(
      (text) => text.setPlaceholder("Enter a character").setValue(this.plugin.settings.fillChar).onChange(async (value) => {
        if (value) {
          if (value.length > 1) {
            value = value.slice(0, 1);
            text.setValue(value);
            new import_obsidian.Notice("Enter only a single character");
          }
          this.plugin.settings.fillChar = value;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Empty character").setDesc("Single character (optional)").addText(
      (text) => text.setPlaceholder("Enter a character").setValue(this.plugin.settings.emptyChar).onChange(async (value) => {
        if (value) {
          if (value.length > 1) {
            value = value.slice(0, 1);
            text.setValue(value);
            new import_obsidian.Notice("Enter only a single character");
          }
          this.plugin.settings.emptyChar = value;
          await this.plugin.saveSettings();
        } else {
          this.plugin.settings.emptyChar = "\u200E";
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Prefix character").setDesc("Single character (optional)").addText(
      (text) => text.setPlaceholder("Enter a character").setValue(this.plugin.settings.prefixChar).onChange(async (value) => {
        if (value.length > 1) {
          value = value.slice(0, 1);
          text.setValue(value);
          new import_obsidian.Notice("Enter only a single character");
        }
        this.plugin.settings.prefixChar = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Suffix character").setDesc("Single character (optional)").addText(
      (text) => text.setPlaceholder("Enter a character").setValue(this.plugin.settings.suffixChar).onChange(async (value) => {
        if (value.length > 1) {
          value = value.slice(0, 1);
          text.setValue(value);
          new import_obsidian.Notice("Enter only a single character");
        }
        this.plugin.settings.suffixChar = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Chart length").setDesc("Length of barchart (excluding prefix/suffix and labels)").addSlider(
      (text) => text.setLimits(10, 50, 10).setValue(this.plugin.settings.chartLength).onChange(async (value) => {
        this.plugin.settings.chartLength = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show labels").setDesc("Display value labels").addToggle(
      (text) => text.setValue(this.plugin.settings.showLabels).onChange(async (value) => {
        this.plugin.settings.showLabels = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Right align labels").setDesc(
      "Align value labels to the right (Recommend disabling if using no empty character)"
    ).addToggle(
      (text) => text.setValue(this.plugin.settings.rightAlignLabels).onChange(async (value) => {
        this.plugin.settings.rightAlignLabels = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Code block (recommended)").setDesc("Render the chart in a codeblock instead of a paragraph").addToggle(
      (text) => text.setValue(this.plugin.settings.codeBlock).onChange(async (value) => {
        this.plugin.settings.codeBlock = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/charts/parseInput.ts
function parseInput(inputString) {
  const data = [];
  const lines = inputString.trim().split("\n");
  for (const line of lines) {
    const [key, value] = line.split(",");
    const trimmedKey = key.trim();
    const trimmedValue = parseInt(value.trim(), 10);
    data.push({ key: trimmedKey, value: trimmedValue });
  }
  return data;
}

// src/charts/horizontalBar.ts
function generateBarChart(data, settings) {
  let chartLength = settings.chartLength;
  let fillChar = settings.fillChar;
  let emptyChar = settings.emptyChar;
  let showLabelsFlag = settings.showLabels;
  let rightAlignLabelsFlag = settings.rightAlignLabels;
  let prefixChar = settings.prefixChar;
  let suffixChar = settings.suffixChar;
  const maxValue = Math.max(...data.map((entry) => entry.value));
  const maxValueLength = maxValue.toString().length;
  const maxKeyLength = Math.max(
    ...data.map((entry) => entry.key.length)
  );
  const barChart = [];
  for (const { key, value } of data) {
    const barLength = Math.floor(value / maxValue * chartLength);
    const bars = fillChar.repeat(barLength) + emptyChar.repeat(chartLength - barLength);
    let value_padded = " " + value.toString();
    if (rightAlignLabelsFlag === true) {
      value_padded = value_padded.padStart(maxValueLength + 1);
    }
    if (showLabelsFlag === true) {
      barChart.push(
        `${key.padEnd(
          maxKeyLength + 2
        )} ${prefixChar}${bars}${suffixChar}${value_padded}`
      );
    } else {
      barChart.push(
        `${key.padEnd(
          maxKeyLength + 2
        )} ${prefixChar}${bars}${suffixChar}`
      );
    }
  }
  return barChart.join("\n");
}

// src/main.ts
var TinyChartPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    this.addCommand({
      id: "horizontal-bar-example",
      name: "Insert horizontal barchart example",
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        editor.replaceSelection(
          "```tinychart\nApples, 100\nBananas, 75\nOranges, 150\nGrapes, 25\nPineapples, 10\nWatermelons, 50\nstrawberries, 150\nBlueberries, 30\nRaspberries, 15\nMangoes, 150\n```"
        );
      }
    });
    this.registerMarkdownCodeBlockProcessor(
      "tinychart",
      (source, el) => {
        try {
          const parsedData = parseInput(source);
          const barChart = generateBarChart(
            parsedData,
            this.settings
          );
          let codeBlockFlag = this.settings.codeBlock;
          let blockType;
          if (codeBlockFlag) {
            blockType = "pre";
          } else {
            blockType = "p";
          }
          const block = el.createEl(blockType, {
            attr: { style: "font-family: monospace;" }
          });
          block.innerText = barChart;
        } catch (error) {
          const errorEl = el.createEl("pre", {
            attr: { style: "color: red; font-family: monospace;" }
          });
          errorEl.innerText = "[TinyChart] \n" + error;
        }
      }
    );
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
